---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Generating Data with Specified Univariate Skewness and Kurtosis

The following is text taken from Valle & Maurelli (1983), Fleishman (1978) and a demonstration using source code from the `semTools` library. 

## Univariate process (Fleishman 1978)
Defining a function based on the `semTools` package to estimate univariate skewness and kurtosis. (Type II skewness and kurtosis).

```{r echo=TRUE}
semToolsuni <- function(x){
  n    <- length(x)
  xbar <- mean(x)

  m2 <- sum((x - xbar)^2) / n
  m3 <- sum((x - xbar)^3) / n
  m4 <- sum((x - xbar)^4) / n

  kstat2 <- m2 * n/(n -1)
  kstat3 <- m3*n^2/((n - 1) * (n - 2))

  num2 <- (n + 1) * m4
  num3 <- 3 * (n - 1) * m2^2
  denom <- (n - 1) * (n - 2) * (n - 3)
  kstat4 <- (n^2 * (num2 - num3))/denom

  skewness <- kstat3 / (kstat2^(3/2))
  kurtosis <- kstat4 / kstat2^2
  return(c(skewness = skewness,kurtosis = kurtosis))
}
```

Fleishman's technique for generating nonnormal random numbers in the univariate case involved defining a variable, $y$, as a linear combination of the first three powers of a standard normal random variable $X$. 

$$Y = a + bX + cX^2 + dX^3$$

$a,b,c,d$ are chosen to provide $y$ with the speficied distributional form. To get these constants Fleishman expanded the above equation to express the first four moments of the nonnormal variable $Y$ into the first 14 moments of normally distributed $X$. 

$$b^2 + 6bd + 2c^2 + 15d^2 -1 = 0$$
$$2c(b^2+24bd+105d^2 + 2) - \gamma_1 =0$$
$$24[bd + c^2(1+b^2+28bd)+d^2(12+48bd+141c^2+225d^2)]-\gamma_2=0$$
$$a = -c$$
where $\gamma_1$ is the desired skewness, and $\gamma_2$ is the desired kurtosis. 

#### Source code: 
```{r echo=TRUE}
#Finds b,c, and d (a = -c, so it also finds a). 
fleishman_abcd <- function(curr_guess, skewness, kurtosis) {
            b. = curr_guess[1L]
            c. = curr_guess[2L]
            d. = curr_guess[3L]
            
            eq1 <- b.^2 + (6 * b. * d.) + (2 * c.^2) + (15 * d.^2) - 
                1
            eq2 <- 2 * c. * (b.^2 + (24 * b. * d.) + (105 * d.^2) + 
                2) - skewness
            eq3 <- 24 * (b. * d. + c.^2 * (1 + b.^2 + 28 * b. * 
                d.) + d.^2 * (12 + 48 * b. * d. + 141 * c.^2 + 
                225 * d.^2)) - kurtosis
            eq <- c(eq1, eq2, eq3)
            sum(eq^2)
}
```

Then, with $a,b,c,d$ we can use the first equation to simulate a univariate nonnormal variable. 
```{r echo=TRUE}
skewness <- 3
kurtosis <- 3

out <- nlminb(start = c(1, 0, 0), objective = fleishman_abcd, 
              scale = 10, control = list(trace = 0), skewness = skewness, 
              kurtosis = kurtosis)

b <- out$par[1]
c <- out$par[2]
d <- out$par[3]
a <- -c
print(round(c(b=b,c=c,d=d,a=a),4))
```

A univariate nonnormal random variable is generated by drawing normal random numbers and transforming them using the constants $a,b,c,d$ as follows: 
$$Y = a + bX + cX^2 + dX^3$$

```{r echo=TRUE}
X <- rnorm(n=10000)
Y <- a + b*X + c*X^2 + d*X^3
semToolsuni(Y)
hist(Y)
```

## Multivariate Case (Valle & Maurelli 1983)

Multivariate random number generation is accomplished using a matrix decoposition procedure (cf. kaiser & Dickman, 1962). A principal components factorization is performed on the population correlation matrix that is to underlie the random numbers. First, one random number is generated for each component and each random vriable is defined as the sum of the products of the variable's component loadings and the random number corresponding to each of the components. When the random numbers input are normal, the resulting random numbers are multivariate normal with population intercorrelations equal to those of hte matrix originally decomposed. 

Multivariate normal random numbers with specified intercorrelations are generated and then univariately transformed to the desired shapes. The two processes interact, however, and the nonnormal numbers have intercorrelations different from the normal ones. To generate random
numbers with specified intercorrelations and moments, the effect of nonnormalizing on
the correlations must be anticipated and counteracted.

Initializing the Fleishman method as a single function: This function returns the Fleishman coefficients with specified univariate skewness and kurtosis:
```{r echo=TRUE}
fleishman1978_abcd <- function(skewness, kurtosis) {
  system.function <- function(x, skewness, kurtosis) {
    b. = x[1L]
    c. = x[2L]
    d. = x[3L]
    eq1 <- b.^2 + 6 * b. * d. + 2 * c.^2 + 15 * d.^2 - 
      1
    eq2 <- 2 * c. * (b.^2 + 24 * b. * d. + 105 * d.^2 + 
                       2) - skewness
    eq3 <- 24 * (b. * d. + c.^2 * (1 + b.^2 + 28 * b. * 
                                     d.) + d.^2 * (12 + 48 * b. * d. + 141 * c.^2 + 
                                                     225 * d.^2)) - kurtosis
    eq <- c(eq1, eq2, eq3)
    sum(eq^2)
  }
  out <- nlminb(start = c(1, 0, 0), objective = system.function, 
                scale = 10, control = list(trace = 0), skewness = skewness, 
                kurtosis = kurtosis)
  if (out$convergence != 0) 
    warning("no convergence")
  b. <- out$par[1L]
  c. <- out$par[2L]
  d. <- out$par[3L]
  a. <- -c.
  c(a., b., c., d.)
}
```

Initializing some values to find Fleishman values for two variables 
$Y_1$ and $Y_2$ with $\mu(Y_1,Y_2) = [0\ 0]$, 
$$ \Sigma=\begin{bmatrix}
1 & 0.3 \\
0.3 & 1
\end{bmatrix}$$
$skew(Y_1) = 3,skew(Y_2) = 4$, and $kurtosis(Y_1) = 6, kurtosis(Y_2) = 8$
```{r}
set.seed(1234)
n     <- 10000
mu    <- c(0,0)
Sigma <- diag(c(1,1))
Sigma[1,2] <- Sigma[2,1] <- 0.3
COR <- cov2cor(Sigma)
skew <- c(3,4)
kurt <- c(6,8)

```

Finding the Fleishman coefficients: 
```{r}
coefs1 <- fleishman1978_abcd(skew[1],kurt[1])
coefs2 <- fleishman1978_abcd(skew[2],kurt[2])
print(coefs1)
print(coefs2)
```

#### Expressing the Fleishman constants in matrix notation

$x' = [1 ,X, X^2,X^3]$ are the powers of X and $$w'=[a,b,c,d]$$
contains the power function weights. Thus, 
$$Y=w'x$$

In the multivariate setting, let $Y_1$ and $Y_2$ be nonnormal variables corresponding to $X_1$ and $X_2$. $r_{Y_i Y_2}$ is the correlation between $Y_1$ and $Y_2$. 

Given that the variables are standardized, $$r_{Y_i Y_2} = E(Y_i\ Y_2) = E(w_1'\ x_1\ x_2'\ w_2) = w_1'Rw_2$$

where $R$ is the expected matrix product of $x_1$ and $x_2$:

$$ R= E(x_1\ x_2)=\begin{bmatrix}
1 & 0 & 1 & 0\\
0 & \rho_{x_1x_2} & 0 & 3\rho_{x_1x_2}\\
1 & 0 & 2\rho^2_{x_1x_2}+1 & 0\\
0 & 3\rho_{x_1x_2} & 0 &6\rho^3_{x_1x_2}+9\rho_{x_1x_2}
\end{bmatrix}$$

In scalar algebra terms, the correlation between the normal variables $X_1$ and $X_2$ results: 
$$r_{x_1x_2}=\rho_{x_1x_2}(b_1b_2+3b_1d_2+3d_1b_2+9d_1d_2) + \rho^2_{x_1x_2}(2c_1c_2)+\rho^3_{x_1x_2}(6d_1d_2)$$
Initializing function that returns the optimal $\rho_{x_1x_2}$ given $b_1,b_2,c_1c_2,d_1,d_2$ and $r_{x_1x_2}$:
```{r}
getICOV <- function(b1, c1, d1, b2, c2, d2, R){
  objectiveFunction <- function(x, b1, c1, d1, b2, c2, 
                                d2, R) {
    rho = x[1L]
    eq <- rho * (b1 * b2 + 3 * b1 * d2 + 3 * d1 * b2 + 
                   9 * d1 * d2) + rho^2 * (2 * c1 * c2) + rho^3 * 
      (6 * d1 * d2) - R
    eq^2
  }
  out <- nlminb(start = R, objective = objectiveFunction, 
                scale = 10, control = list(trace = 0), b1 = b1, c1 = c1, 
                d1 = d1, b2 = b2, c2 = c2, d2 = d2, R = R)
  if (out$convergence != 0) 
    warning("no convergence")
  rho <- out$par[1L]
  rho
}
```

Finding optimal $r_{x_1x_2}$ with Flesihman coefficients: 
```{r}
rho12 <- getICOV(b1 = coefs1[2],c1 = coefs1[3],d1 = coefs1[4],R=Sigma[1,2],
                b2 = coefs2[2],c2 = coefs2[3],d2 = coefs2[4])
new.sigma <- diag(2)
new.sigma[1,2] <- new.sigma[2,1] <- rho12
new.sigma
```

The new $r_{x_1x_2} = $   `r round(rho12,3)`. 

Therefore, we sample from a bivariate normal distribution with $\mu= [0 \ 0 ]$ and 
$$ \Sigma=\begin{bmatrix}
1 & r_{x_1x_2} \\
r_{x_1x_2} & 1
\end{bmatrix}$$
as calculated by the principal components factorization procedure.  

```{r}
Z   <- MASS::mvrnorm(n = n, mu = rep(0, 2), Sigma = new.sigma)
```

Similarly to the univariate method, we transform $Z$ such that: 

$$Y_{ij} = a_{j} + b_jZ_{ij} + c_jZ_{ij}^2 + d_jZ_{ij}^3$$
```{r}
Y.raw <- matrix(0,nrow=n,ncol=2)
Y.raw[,1] <- coefs1[1] + coefs1[2]*Z[,1] + coefs1[3]*Z[,1] + coefs1[4]*Z[,1]
Y.raw[,2] <- coefs2[1] + coefs2[2]*Z[,1] + coefs2[3]*Z[,1] + coefs2[4]*Z[,1]
```

Finally we re-scale $Y_{ij}$ with the desired mean and variance. 
```{r}
Y.varscale <- scale(Y.raw, center = FALSE, scale = 1/sqrt(diag(Sigma)))[,,drop = FALSE]
Y          <- sweep(Y.varscale, MARGIN = 2, STATS = mu, FUN = "+")
```

Calculating moments for $Y$:
```{r}
colMeans(Y)
cov(Y)
mnonr::mardia(Y)
```


## Source code from semTools which generalizes to multiple variables
```{r echo=TRUE}
set.seed(1234)
n     <- 1000
mu    <- c(0,0)
Sigma <- diag(c(1,1))
COR <- cov2cor(Sigma)
skew <- c(3,3)
kurt <- c(6,6)
empirical <- FALSE
    
p  <- length(mu)
eS <- eigen(Sigma, symmetric = TRUE)
ev <- eS$values
    
if (!all(ev >= -1e-06 * abs(ev[1L]))) 
        stop("'Sigma' is not positive definite")

nvar <- ncol(COR)

FTable <- matrix(0, nvar, 4L)
for (i in 1:nvar) {
        FTable[i, ] <- fleishman1978_abcd(skewness = skew[i], kurtosis = kurt[i])
}

#Calculate intercorrelations: 
ICOR <- diag(nvar)
  #These for loops go through each non-diagonal lower triangular element. 
  for (j in 1:(nvar - 1L)) {
    for (i in (j + 1):nvar) {
      if (COR[i, j] == 0)
        next
      ICOR[i, j] <- ICOR[j, i] <- getICOV(FTable[i, 2],FTable[i, 3], FTable[i, 4], 
                                          FTable[j, 2], FTable[j,3], FTable[j, 4], 
                                          R = COR[i, j])
    }
  }

Z   <- MASS::mvrnorm(n = n, mu = rep(0, nvar), Sigma = ICOR)
X.Z <- matrix(NA,nrow=n,ncol=nvar)

for (i in 1:nvar) {
  X.Z[, i] <- FTable[i, 1L] + FTable[i, 2L] * Z[, i] + FTable[i,3L] * Z[, i]^2 + FTable[i, 4L] * Z[, i]^3
}

TMP <- scale(X.Z, center = FALSE, scale = 1/sqrt(diag(Sigma)))[,,drop = FALSE]
X   <- sweep(TMP, MARGIN = 2, STATS = mu, FUN = "+")
```

# Shortening source code for univariate data: 

```{r echo=TRUE}
set.seed(1234)
n     <- 1000
mu    <- 0
s2    <- 25
skew <-  3
kurt <-  6

FTable <-  fleishman1978_abcd(skewness = skew, kurtosis = kurt)
Zuni <- MASS::mvrnorm(n = n, mu = rep(0, 2), Sigma = diag(c(1,1)))[,1]
Xuni <- sqrt(s2) * (FTable[1L] + FTable[2L] * Zuni + FTable[3L] * Zuni^2 + FTable[4L] * Zuni^3)
```